{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Python Rest Client Schema Registry","text":"<p>Python Rest Client to interact against schema-registry confluent server to manage Avro and JSON schemas resources.</p>"},{"location":"#requirements","title":"Requirements","text":"<p>python 3.6+</p>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install python-schema-registry-client\n</code></pre> <p>If you want the <code>Faust</code> functionality:</p> <pre><code>pip install python-schema-registry-client[faust]\n</code></pre>"},{"location":"#usage","title":"Usage","text":"Trival Usage with avro<pre><code>from schema_registry.client import SchemaRegistryClient, schema\n\nclient = SchemaRegistryClient(url=\"http://127.0.0.1:8081\")\n\ndeployment_schema = {\n    \"type\": \"record\",\n    \"namespace\": \"com.kubertenes\",\n    \"name\": \"AvroDeployment\",\n    \"fields\": [\n        {\"name\": \"image\", \"type\": \"string\"},\n        {\"name\": \"replicas\", \"type\": \"int\"},\n        {\"name\": \"port\", \"type\": \"int\"},\n    ],\n}\n\navro_schema = schema.AvroSchema(deployment_schema)\n\nschema_id = client.register(\"test-deployment\", avro_schema)\n</code></pre> Trival Usage Async with avro<pre><code>from schema_registry.client import AsyncSchemaRegistryClient, schema\n\nasync_client = AsyncSchemaRegistryClient(url=\"http://127.0.0.1:8081\")\n\ndeployment_schema = {\n    \"type\": \"record\",\n    \"namespace\": \"com.kubertenes\",\n    \"name\": \"AvroDeployment\",\n    \"fields\": [\n        {\"name\": \"image\", \"type\": \"string\"},\n        {\"name\": \"replicas\", \"type\": \"int\"},\n        {\"name\": \"port\", \"type\": \"int\"},\n    ],\n}\n\navro_schema = schema.AvroSchema(deployment_schema)\n\nschema_id = await async_client.register(\"test-deployment\", avro_schema)\n</code></pre> Trival Usage with json schemas<pre><code>from schema_registry.client import SchemaRegistryClient, schema\n\nclient = SchemaRegistryClient(url=\"http://127.0.0.1:8081\")\n\ndeployment_schema = {\n    \"definitions\" : {\n        \"JsonDeployment\" : {\n            \"type\" : \"object\",\n            \"required\" : [\"image\", \"replicas\", \"port\"],\n            \"properties\" : {\n                \"image\" :       {\"type\" : \"string\"},\n                \"replicas\" :    {\"type\" : \"integer\"},\n                \"port\" :        {\"type\" : \"integer\"}\n            }\n        }\n    },\n    \"$ref\" : \"#/definitions/JsonDeployment\"\n}\n\njson_schema = schema.JsonSchema(deployment_schema)\n\nschema_id = client.register(\"test-deployment\", json_schema)\n</code></pre> Trival Usage Asynv with json schemas<pre><code>from schema_registry.client import AsyncSchemaRegistryClient, schema\n\nasync_client = AsyncSchemaRegistryClient(url=\"http://127.0.0.1:8081\")\n\ndeployment_schema = {\n    \"definitions\" : {\n        \"JsonDeployment\" : {\n            \"type\" : \"object\",\n            \"required\" : [\"image\", \"replicas\", \"port\"],\n            \"properties\" : {\n                \"image\" :       {\"type\" : \"string\"},\n                \"replicas\" :    {\"type\" : \"integer\"},\n                \"port\" :        {\"type\" : \"integer\"}\n            }\n        }\n    },\n    \"$ref\" : \"#/definitions/JsonDeployment\"\n}\n\njson_schema = schema.JsonSchema(deployment_schema)\n\nschema_id = await async_client.register(\"test-deployment\", json_schema)\n</code></pre>"},{"location":"#usage-with-dataclasses-avroschema","title":"Usage with dataclasses-avroschema","text":"<p>You can generate the <code>avro schema</code> and <code>json schemas</code> directely from a python class using dataclasses-avroschema and use it in the API for <code>register schemas</code>, <code>check versions</code> and <code>test compatibility</code>:</p> Trival Usage with dataclasses-avroschema<pre><code>import dataclasses\nfrom enum import Enum\nimport typing\n\nfrom dataclasses_avroschema import AvroModel\nfrom schema_registry.client import SchemaRegistryClient\n\nclient = SchemaRegistryClient(url=\"http://127.0.0.1:8081\")\n\n\nclass ColorEnum(str, Enum):\n    BLUE = \"BLUE\"\n    YELLOW = \"YELLOW\"\n    GREEN = \"GREEN\"\n\n\n@dataclasses.dataclass\nclass UserAdvance(AvroModel):\n    name: str\n    age: int\n    pets: typing.List[str] = dataclasses.field(default_factory=lambda: [\"dog\", \"cat\"])\n    accounts: typing.Dict[str, int] = dataclasses.field(default_factory=lambda: {\"key\": 1})\n    has_car: bool = False\n    favorite_colors: ColorEnum = ColorEnum.BLUE\n    country: str = \"Argentina\"\n    address: str = None\n\nsubject = \"subject\"\n\n# register the schema\nschema_id = client.register(subject, UserAdvance.avro_schema())\n\nprint(schema_id)\n# &gt;&gt;&gt; 12\n\nresult = client.check_version(subject, UserAdvance.avro_schema())\nprint(result)\n# &gt;&gt;&gt; SchemaVersion(subject='dataclasses-avroschema-subject-2', schema_id=12, schema=1, version={\"type\":\"record\" ...')\n\ncompatible = client.test_compatibility(subject, UserAdvance.avro_schema())\nprint(compatible)\n# &gt;&gt;&gt; True\n</code></pre> <p>Note</p> <p>You can generate json schemas with <code>dataclasses-avroschema</code> adding the pydantic batteries</p>"},{"location":"#usage-with-pydantic-for-json-schemas","title":"Usage with pydantic for json schemas","text":"<p>You can generate the json schema directely from a python class using pydantic and use it in the API for register schemas, check versions and test compatibility:</p> Trival Usage with pydantic<pre><code>import typing\nfrom enum import Enum\n\nfrom pydantic import BaseModel\nfrom schema_registry.client import SchemaRegistryClient\n\nclient = SchemaRegistryClient(url=\"http://127.0.0.1:8081\")\n\nclass ColorEnum(str, Enum):\n  BLUE = \"BLUE\"\n  YELLOW = \"YELLOW\"\n  GREEN = \"GREEN\"\n\n\nclass UserAdvance(BaseModel):\n    name: str\n    age: int\n    pets: typing.List[str] = [\"dog\", \"cat\"]\n    accounts: typing.Dict[str, int] = {\"key\": 1}\n    has_car: bool = False\n    favorite_colors: ColorEnum = ColorEnum.BLUE\n    country: str = \"Argentina\"\n    address: str = None\n\nsubject = \"subject\"\n\n# register the schema\nschema_id = client.register(subject, UserAdvance.schema_json(), schema_type=\"JSON\")\n\nprint(schema_id)\n# &gt;&gt;&gt; 12\n\nresult = client.check_version(subject, UserAdvance.schema_json(), schema_type=\"JSON\")\nprint(result)\n# &gt;&gt;&gt; SchemaVersion(subject='pydantic-jsonschema-subject', schema_id=12, schema=1, version=&lt;schema_registry.client.schema.JsonSchema object at 0x7f40354550a0&gt;)\n\ncompatible = client.test_compatibility(subject, UserAdvance.schema_json(), schema_type=\"JSON\")\nprint(compatible)\n# &gt;&gt;&gt; True\n</code></pre>"},{"location":"#when-use-this-library","title":"When use this library","text":"<p>Usually, we have a situacion like this:</p> <p></p> <p>So, our producers/consumers have to serialize/deserialize messages every time that they send/receive from Kafka topics. In this picture, we can imagine a <code>Faust</code> application receiving messages (encoded with an Avro schema) and we want to deserialize them, so we can ask the <code>schema server</code> to do that for us. In this scenario, the <code>MessageSerializer</code> is perfect.</p> <p>Also, could be a use case that we would like to have an Application only to administrate <code>Avro Schemas</code> (register, update compatibilities, delete old schemas, etc.), so the <code>SchemaRegistryClient</code> is perfect.</p>"},{"location":"#development","title":"Development","text":"<p>Poetry is needed to install the dependencies and develope locally</p> <ol> <li>Install dependencies: <code>poetry install --all-extras</code></li> <li>Code linting: <code>./scripts/format</code></li> <li>Run tests: <code>./scripts/test</code></li> </ol> <p>For commit messages we use commitizen in order to standardize a way of committing rules</p> <p>Note: The tests are run against the <code>Schema Server</code> using <code>docker compose</code>, so you will need <code>Docker</code> and <code>Docker Compose</code> installed.</p> <p>You can run tests with arbitrary python version by:</p> <pre><code>./scripts/test --python-version 3.x\n</code></pre> <p>All additional args will be passed to pytest, for example:</p> <pre><code>./scripts/test ./tests/client/ --maxfail=1 </code></pre>"},{"location":"#tests-usind-the-python-shell","title":"Tests usind the python shell","text":"<p>To perform tests using the python shell you can run the project using <code>docker-compose</code>.</p> <ol> <li>Build: <code>docker-compose build --build-arg PYTHON_VERSION=$PYTHON_VERSION</code></li> <li>Execute <code>docker-compose up</code>. Then, the <code>schema registry server</code> will run on <code>http://127.0.0.1:8081</code>, then you can interact against it using the <code>SchemaRegistryClient</code>:</li> <li>Use the python interpreter (get a python shell typing <code>python</code> in your command line)</li> <li>Play with the <code>schema server</code></li> </ol> <pre><code>from schema_registry.client import SchemaRegistryClient, schema\n\nclient = SchemaRegistryClient(url=\"http://127.0.0.1:8081\")\n\n# do some operations with the client...\ndeployment_schema = {\n    \"type\": \"record\",\n    \"namespace\": \"com.kubertenes\",\n    \"name\": \"AvroDeployment\",\n    \"fields\": [\n        {\"name\": \"image\", \"type\": \"string\"},\n        {\"name\": \"replicas\", \"type\": \"int\"},\n        {\"name\": \"port\", \"type\": \"int\"},\n    ],\n}\n\navro_schema = schema.AvroSchema(deployment_schema)\nclient.register(\"test-deployment\", avro_schema)\n# &gt;&gt;&gt;&gt; Out[5]: 1\n</code></pre> <p>Then, you can check the schema using your browser going to the url <code>http://127.0.0.1:8081/schemas/ids/1</code></p>"},{"location":"client/","title":"Client","text":"<p>The <code>Schema Registry Client</code> consumes the API exposed by the <code>schema-registry</code> to operate resources that are <code>avro</code> and <code>json</code> schemas.</p> <p>You probably won't use this but is good to know that exists. The <code>MessageSerializer</code> is whom interact with the <code>SchemaRegistryClient</code></p>"},{"location":"client/#schemaregistryclient","title":"SchemaRegistryClient","text":"class <code>schema_registry.client.SchemaRegistryClient</code>(url, ca_location=None, cert_location=None, key_location=None, key_password=None, extra_headers=None, timeout=None, pool_limits=None, auth=None) <p>A client that talks to a Schema Registry over HTTP</p> <p>Parameters:</p> <ul> <li>url - (Union[str, Dict]: Url to schema registry or dictionary containing client configuration.</li> <li>ca_location - Optional[str]: File or directory path to CA certificate(s) for     verifying the Schema Registry key.</li> <li>cert_location - Optional[str]: Path to public key used for authentication.</li> <li>key_location - Optional[str]: Path to private key used for authentication.</li> <li>key_password - Optional[str]: Key password.</li> <li>extra_headers - Optional[Dict[str, str]]: Extra headers to add on every requests.</li> <li>timeout - Optional[httpx._client.TimeoutTypes]  The timeout configuration to use when sending requests.</li> <li>pool_limits - Optional[httpx.Limits]) The connection pool configuration to use when     determining the maximum number of concurrently open HTTP connections.</li> <li>auth - (optional) (schema_registry.client.Auth) Auth credentials.</li> </ul>"},{"location":"client/#auth","title":"Auth","text":"<p>Credentials can be supplied in <code>two</code> different ways: using the <code>url</code> or the <code>schema_registry.client.Auth</code>.</p> Credentials using Auth<pre><code>from schema_registry.client import SchemaRegistryClient, Auth\n\nSchemaRegistryClient(\n    url=\"https://user_url:secret_url@127.0.0.1:65534\",\n    auth=Auth(username=\"secret-user\", password=\"secret\"),\n)\n</code></pre> Credentials using the url<pre><code>from schema_registry.client import SchemaRegistryClient\n\nusername=\"secret-username\"\npassword=\"secret\"\n\nSchemaRegistryClient({\"url\": f\"https://{username}:{password}@127.0.0.1:65534\"})\n</code></pre> <p>Note</p> <p>This auth methods are the same for <code>AsyncSchemaRegistryClient</code></p>"},{"location":"client/#methods","title":"Methods","text":""},{"location":"client/#get-schema","title":"Get Schema","text":"<p>Get Schema for a given version. If version is <code>None</code>, try to resolve the latest schema</p> <pre><code>def get_schema(subject: str, version=\"latest\", headers: dict = None, timeout: typing.Union[TimeoutTypes, UseClientDefault] = USE_CLIENT_DEFAULT) -&gt; utils.SchemaVersion:\n\"\"\"\n    Args:\n        subject (str): subject name\n        version (int, optional): version id. If is None, the latest schema is returned\n        headers (dict): Extra headers to add on the requests\n        timeout (httpx._client.TimeoutTypes): The timeout configuration to use when sending requests. Default USE_CLIENT_DEFAULT\n\n    Returns:\n        utils.SchemaVersion (nametupled): (subject, schema_id, schema, version)\n\n        None: If server returns a not success response:\n            404: Schema not found\n            422: Unprocessable entity\n            ~ (200 - 299): Not success\n    \"\"\"\n</code></pre>"},{"location":"client/#get-schema-by-id","title":"Get schema by <code>id</code>","text":"<pre><code>def get_by_id(schema_id: int, headers: dict = None, timeout: typing.Union[TimeoutTypes, UseClientDefault] = USE_CLIENT_DEFAULT) -&gt; typing.Union[client.schema.AvroSchema, client.schema.JsonSchema]:\n\"\"\"\n    Args:\n        schema_id (int): Schema Id\n        headers (dict): Extra headers to add on the requests\n        timeout (httpx._client.TimeoutTypes): The timeout configuration to use when sending requests. Default USE_CLIENT_DEFAULT\n\n    Returns:\n        typing.Union[client.schema.AvroSchema, client.schema.JsonSchema]: Avro or JSON Record schema\n    \"\"\"\n</code></pre>"},{"location":"client/#register-a-schema","title":"Register a Schema","text":"<pre><code>def register(subject: str, schema: typing.Union[client.schema.AvroSchema, client.schema.JsonSchema], headers: dict = None, timeout: typing.Union[TimeoutTypes, UseClientDefault] = USE_CLIENT_DEFAULT, schema_type: typing.Union[\"AVRO\", \"JSON\"]) -&gt; int:\n\"\"\"\n    Args:\n        subject (str): subject name\n        schema typing.Union[client.schema.AvroSchema, client.schema.JsonSchema, str]: Avro or JSON schema to be registered\n        headers (dict): Extra headers to add on the requests\n        timeout (httpx._client.TimeoutTypes): The timeout configuration to use when sending requests. Default USE_CLIENT_DEFAULT\n        schema_type typing.Union[\"AVRO\", \"JSON\"]: The type of schema to parse if `schema` is a string. Default \"AVRO\"\n\n    Returns:\n        int: schema_id\n    \"\"\"\n</code></pre>"},{"location":"client/#get-subjects","title":"Get Subjects","text":"<pre><code>def get_subjects(self, headers: dict = None, timeout: typing.Union[TimeoutTypes, UseClientDefault] = USE_CLIENT_DEFAULT) -&gt; list:\n\"\"\"\n    GET /subjects/(string: subject)\n    Get list of all registered subjects in your Schema Registry.\n\n    Args:\n        subject (str): subject name\n        headers (dict): Extra headers to add on the requests\n        timeout (httpx._client.TimeoutTypes): The timeout configuration to use when sending requests. Default USE_CLIENT_DEFAULT\n\n    Returns:\n        list [str]: list of registered subjects.\n    \"\"\"\n</code></pre>"},{"location":"client/#get-subjects-versions","title":"Get Subjects Versions","text":"<pre><code>async def get_schema_subject_versions(self, schema_id: int, headers: dict = None, timeout: typing.Union[TimeoutTypes, UseClientDefault] = USE_CLIENT_DEFAULT,) -&gt; typing.Optional[typing.List[SubjectVersion]]:\n\"\"\"\n    GET /schemas/ids/{int: id}/versions\n    Get the subject-version pairs identified by the input ID.\n\n    Args:\n        schema_id (int): Schema Id\n        headers (dict): Extra headers to add on the requests\n        timeout (httpx._client.TimeoutTypes): The timeout configuration to use when sending requests.\n                Default USE_CLIENT_DEFAULT\n\n    Returns:\n        typing.List[SubjectVersion]: List of Subject/Version pairs where Schema Id is registered\n    \"\"\"\n</code></pre>"},{"location":"client/#delete-schema","title":"Delete Schema","text":"<pre><code>def delete_subject(subject: str, headers: dict = None, timeout: typing.Union[TimeoutTypes, UseClientDefault] = USE_CLIENT_DEFAULT) -&gt; list:\n\"\"\"\n    Args:\n        subject (str): subject name\n        headers (dict): Extra headers to add on the requests\n        timeout (httpx._client.TimeoutTypes): The timeout configuration to use when sending requests. Default USE_CLIENT_DEFAULT\n\n    Returns:\n        list (int): versions of the schema deleted under this subject\n    \"\"\"\n</code></pre>"},{"location":"client/#check-if-a-schema-has-already-been-registered-under-the-specified-subject","title":"Check if a schema has already been registered under the specified subject","text":"<pre><code>def check_version(subject: str, schema: typing.Union[client.schema.AvroSchema, client.schema.JsonSchema], headers: dict = None, timeout: typing.Union[TimeoutTypes, UseClientDefault] = USE_CLIENT_DEFAULT, schema_type: typing.Union[\"AVRO\", \"JSON\"]) -&gt; dict:\n\"\"\"\n    Args:\n        subject (str): subject name\n        schema typing.Union[client.schema.AvroSchema, client.schema.JsonSchema, str]: Avro or JSON schema to be registered\n        headers (dict): Extra headers to add on the requests\n        timeout (httpx._client.TimeoutTypes): The timeout configuration to use when sending requests. Default USE_CLIENT_DEFAULT\n        schema_type typing.Union[\"AVRO\", \"JSON\"]: The type of schema to parse if `schema` is a string. Default \"AVRO\"\n\n    Returns:\n        dict:\n            subject (string) -- Name of the subject that this schema is registered under\n            id (int) -- Globally unique identifier of the schema\n            version (int) -- Version of the returned schema\n            schema (dict) -- The Avro or JSON schema\n\n        None: If schema not found.\n    \"\"\"\n</code></pre>"},{"location":"client/#get-schema-version-under-a-specific-subject","title":"Get schema version under a specific subject","text":"<pre><code>def get_versions(self, subject: str, headers: dict = None, timeout: typing.Union[TimeoutTypes, UseClientDefault] = USE_CLIENT_DEFAULT) -&gt; list:\n\"\"\"\n    GET subjects/{subject}/versions\n    Get a list of versions registered under the specified subject.\n\n    Args:\n        subject (str): subject name\n        headers (dict): Extra headers to add on the requests\n        timeout (httpx._client.TimeoutTypes): The timeout configuration to use when sending requests. Default USE_CLIENT_DEFAULT\n\n    Returns:\n        list (str): version of the schema registered under this subject\n    \"\"\"\n</code></pre>"},{"location":"client/#deletes-a-specific-version-of-the-schema-registered-under-a-subject","title":"Deletes a specific version of the schema registered under a subject","text":"<pre><code>def delete_version(self, subject: str, version=\"latest\", headers: dict = None, timeout: typing.Union[TimeoutTypes, UseClientDefault] = USE_CLIENT_DEFAULT):\n\"\"\"\n    DELETE /subjects/(string: subject)/versions/(versionId: version)\n\n    Deletes a specific version of the schema registered under this subject.\n    This only deletes the version and the schema ID remains intact making\n    it still possible to decode data using the schema ID.\n    This API is recommended to be used only in development environments or\n    under extreme circumstances where-in, its required to delete a previously\n    registered schema for compatibility purposes or re-register previously registered schema.\n\n    Args:\n        subject (str): subject name\n        version (str): Version of the schema to be deleted.\n            Valid values for versionId are between [1,2^31-1] or the string \"latest\".\n            \"latest\" deletes the last registered schema under the specified subject.\n        headers (dict): Extra headers to add on the requests\n        timeout (httpx._client.TimeoutTypes): The timeout configuration to use when sending requests. Default USE_CLIENT_DEFAULT\n\n    Returns:\n        int: version of the schema deleted\n        None: If the subject or version does not exist.\n    \"\"\"\n</code></pre>"},{"location":"client/#test-compatibility","title":"Test Compatibility","text":"<pre><code>def test_compatibility(subject: str, schema: typing.Union[client.schema.AvroSchema, client.schema.JsonSchema], version=\"latest\", headers: dict = None, timeout: typing.Union[TimeoutTypes, UseClientDefault] = USE_CLIENT_DEFAULT, schema_type: typing.Union[\"AVRO\", \"JSON\"]):\n\"\"\"\n    By default the latest version is checked against.\n\n    Args:\n        subject (str): subject name\n        schema typing.Union[client.schema.AvroSchema, client.schema.JsonSchema, str]: Avro or JSON schema to be registered\n        headers (dict): Extra headers to add on the requests\n        timeout (httpx._client.TimeoutTypes): The timeout configuration to use when sending requests. Default USE_CLIENT_DEFAULT\n        schema_type typing.Union[\"AVRO\", \"JSON\"]: The type of schema to parse if `schema` is a string. Default \"AVRO\"\n\n    Returns:\n        bool: True if schema given compatible, False otherwise\n    \"\"\"\n</code></pre>"},{"location":"client/#get-compatibility","title":"Get Compatibility","text":"<pre><code>def get_compatibility(subject: str, headers: dict = None, timeout: typing.Union[TimeoutTypes, UseClientDefault] = USE_CLIENT_DEFAULT) -&gt; str:\n\"\"\"\n    Get the current compatibility level for a subject.  Result will be one of:\n\n    Args:\n        subject (str): subject name\n        headers (dict): Extra headers to add on the requests\n        timeout (httpx._client.TimeoutTypes): The timeout configuration to use when sending requests. Default USE_CLIENT_DEFAULT\n\n    Returns:\n        str: one of BACKWARD, BACKWARD_TRANSITIVE, FORWARD, FORWARD_TRANSITIVE,\n            FULL, FULL_TRANSITIVE, NONE\n\n    Raises:\n        ClientError: if the request was unsuccessful or an invalid\n        compatibility level was returned\n    \"\"\"\n</code></pre>"},{"location":"client/#update-compatibility","title":"Update Compatibility","text":"<pre><code>def update_compatibility(level: str, subject: str, headers: dict = None, timeout: typing.Union[TimeoutTypes, UseClientDefault] = USE_CLIENT_DEFAULT) -&gt; bool:\n\"\"\"\n    Update the compatibility level for a subject.\n    If subject is None, the compatibility level is global.\n\n    Args:\n        level (str): one of BACKWARD, BACKWARD_TRANSITIVE, FORWARD, FORWARD_TRANSITIVE,\n            FULL, FULL_TRANSITIVE, NONE\n        headers (dict): Extra headers to add on the requests\n        timeout (httpx._client.TimeoutTypes): The timeout configuration to use when sending requests. Default USE_CLIENT_DEFAULT\n\n    Returns:\n        bool: True if compatibility was updated\n\n    Raises:\n        ClientError: if the request was unsuccessful or an invalid\n    \"\"\"\n</code></pre>"},{"location":"client/#asyncschemaregistryclient","title":"AsyncSchemaRegistryClient","text":"class <code>schema_registry.client.AsyncSchemaRegistryClient</code>(url, ca_location=None, cert_location=None, key_location=None, key_password=None, extra_headers=None, timeout=None, pool_limits=None, auth=None) <p>A client that talks to a Schema Registry over HTTP</p> <p>Parameters:</p> <ul> <li>url - (Union[str, Dict]: Url to schema registry or dictionary containing client configuration.</li> <li>ca_location - Optional[str]: File or directory path to CA certificate(s)     for verifying the Schema Registry key.</li> <li>cert_location - Optional[str]: Path to public key used for authentication.</li> <li>key_location - Optional[str]: Path to private key used for authentication.</li> <li>key_password - Optional[str]: Key password</li> <li>extra_headers - Optional[Dict[str, str]]: Extra headers to add on every requests.</li> <li>timeout - Optional[httpx._client.TimeoutTypes]  The timeout configuration to use when sending requests.</li> <li>pool_limits - Optional[httpx.Limits]) The connection pool configuration to use when     determining the maximum number of concurrently open HTTP connections.</li> <li>auth - (optional) (schema_registry.client.Auth) Auth credentials.</li> </ul>"},{"location":"client/#methods_1","title":"Methods","text":""},{"location":"client/#get-schema_1","title":"Get Schema","text":"<p>Get Schema for a given version. If version is <code>None</code>, try to resolve the latest schema</p> <pre><code>async def get_schema(subject: str, version=\"latest\", headers: dict = None, timeout: typing.Union[TimeoutTypes, UseClientDefault] = USE_CLIENT_DEFAULT) -&gt; utils.SchemaVersion:\n\"\"\"\n    Args:\n        subject (str): subject name\n        version (int, optional): version id. If is None, the latest schema is returned\n        headers (dict): Extra headers to add on the requests\n        timeout (httpx._client.TimeoutTypes): The timeout configuration to use when sending requests. Default USE_CLIENT_DEFAULT\n\n    Returns:\n        utils.SchemaVersion (nametupled): (subject, schema_id, schema, version)\n\n        None: If server returns a not success response:\n            404: Schema not found\n            422: Unprocessable entity\n            ~ (200 - 299): Not success\n    \"\"\"\n</code></pre>"},{"location":"client/#get-schema-by-id_1","title":"Get schema by <code>id</code>","text":"<pre><code>async def get_by_id(schema_id: int, headers: dict = None, timeout: typing.Union[TimeoutTypes, UseClientDefault] = USE_CLIENT_DEFAULT) -&gt; typing.Union[client.schema.AvroSchema, client.schema.JsonSchema]:\n\"\"\"\n    Args:\n        schema_id (int): Schema Id\n        headers (dict): Extra headers to add on the requests\n        timeout (httpx._client.TimeoutTypes): The timeout configuration to use when sending requests. Default USE_CLIENT_DEFAULT\n\n    Returns:\n        typing.Union[client.schema.AvroSchema, client.schema.JsonSchema]: Avro or JSON Record schema\n    \"\"\"\n</code></pre>"},{"location":"client/#register-a-schema_1","title":"Register a Schema","text":"<pre><code>async def register(subject: str, schema: typing.Union[client.schema.AvroSchema, client.schema.JsonSchema] headers: dict = None, timeout: typing.Union[TimeoutTypes, UseClientDefault] = USE_CLIENT_DEFAULT, schema_type: typing.Union[\"AVRO\", \"JSON\"]) -&gt; int:\n\"\"\"\n    Args:\n        subject (str): subject name\n        schema typing.Union[client.schema.AvroSchema, client.schema.JsonSchema, str]: Avro or JSON schema to be registered\n        headers (dict): Extra headers to add on the requests\n        timeout (httpx._client.TimeoutTypes): The timeout configuration to use when sending requests. Default USE_CLIENT_DEFAULT\n        schema_type typing.Union[\"AVRO\", \"JSON\"]: The type of schema to parse if `schema` is a string. Default \"AVRO\"\n\n    Returns:\n        int: schema_id\n    \"\"\"\n</code></pre>"},{"location":"client/#get-subjects_1","title":"Get Subjects","text":"<pre><code>async def get_subjects(self, headers: dict = None, timeout: typing.Union[TimeoutTypes, UseClientDefault] = USE_CLIENT_DEFAULT) -&gt; list:\n\"\"\"\n    GET /subjects/(string: subject)\n    Get list of all registered subjects in your Schema Registry.\n\n    Args:\n        subject (str): subject name\n        headers (dict): Extra headers to add on the requests\n        timeout (httpx._client.TimeoutTypes): The timeout configuration to use when sending requests. Default USE_CLIENT_DEFAULT\n\n    Returns:\n        list [str]: list of registered subjects.\n    \"\"\"\n</code></pre>"},{"location":"client/#get-subjects-versions_1","title":"Get Subjects Versions","text":"<pre><code>async def get_schema_subject_versions(self, schema_id: int, headers: dict = None, timeout: typing.Union[TimeoutTypes, UseClientDefault] = USE_CLIENT_DEFAULT,) -&gt; typing.Optional[typing.List[SubjectVersion]]:\n\"\"\"\n    GET /schemas/ids/{int: id}/versions\n    Get the subject-version pairs identified by the input ID.\n\n    Args:\n        schema_id (int): Schema Id\n        headers (dict): Extra headers to add on the requests\n        timeout (httpx._client.TimeoutTypes): The timeout configuration to use when sending requests.\n                Default USE_CLIENT_DEFAULT\n\n    Returns:\n        typing.List[SubjectVersion]: List of Subject/Version pairs where Schema Id is registered\n    \"\"\"\n</code></pre>"},{"location":"client/#delete-schema_1","title":"Delete Schema","text":"<pre><code>async def delete_subject(subject: str, headers: dict = None, timeout: typing.Union[TimeoutTypes, UseClientDefault] = USE_CLIENT_DEFAULT) -&gt; list:\n\"\"\"\n    Args:\n        subject (str): subject name\n        headers (dict): Extra headers to add on the requests\n        timeout (httpx._client.TimeoutTypes): The timeout configuration to use when sending requests. Default USE_CLIENT_DEFAULT\n\n    Returns:\n        list (int): versions of the schema deleted under this subject\n    \"\"\"\n</code></pre>"},{"location":"client/#check-if-a-schema-has-already-been-registered-under-the-specified-subject_1","title":"Check if a schema has already been registered under the specified subject","text":"<pre><code>async def check_version(subject: str, schema: typing.Union[client.schema.AvroSchema, client.schema.JsonSchema], headers: dict = None, timeout: typing.Union[TimeoutTypes, UseClientDefault] = USE_CLIENT_DEFAULT, schema_type: typing.Union[\"AVRO\", \"JSON\"]) -&gt; dict:\n\"\"\"\n    Args:\n        subject (str): subject name\n        schema typing.Union[client.schema.AvroSchema, client.schema.JsonSchema, str]: Avro or JSON schema to be registered\n        headers (dict): Extra headers to add on the requests\n        timeout (httpx._client.TimeoutTypes): The timeout configuration to use when sending requests. Default USE_CLIENT_DEFAULT\n        schema_type typing.Union[\"AVRO\", \"JSON\"]: The type of schema to parse if `schema` is a string. Default \"AVRO\"\n\n    Returns:\n        dict:\n            subject (string) -- Name of the subject that this schema is registered under\n            id (int) -- Globally unique identifier of the schema\n            version (int) -- Version of the returned schema\n            schema (dict) -- The Avro or JSON schema\n\n        None: If schema not found.\n    \"\"\"\n</code></pre>"},{"location":"client/#get-schema-version-under-a-specific-subject_1","title":"Get schema version under a specific subject","text":"<pre><code>async def get_versions(self, subject: str, headers: dict = None, timeout: typing.Union[TimeoutTypes, UseClientDefault] = USE_CLIENT_DEFAULT) -&gt; list:\n\"\"\"\n    GET subjects/{subject}/versions\n    Get a list of versions registered under the specified subject.\n\n    Args:\n        subject (str): subject name\n        headers (dict): Extra headers to add on the requests\n        timeout (httpx._client.TimeoutTypes): The timeout configuration to use when sending requests. Default USE_CLIENT_DEFAULT\n\n    Returns:\n        list (str): version of the schema registered under this subject\n    \"\"\"\n</code></pre>"},{"location":"client/#deletes-a-specific-version-of-the-schema-registered-under-a-subject_1","title":"Deletes a specific version of the schema registered under a subject","text":"<pre><code>async def delete_version(self, subject: str, version=\"latest\", headers: dict = None, timeout: typing.Union[TimeoutTypes, UseClientDefault] = USE_CLIENT_DEFAULT):\n\"\"\"\n    DELETE /subjects/(string: subject)/versions/(versionId: version)\n\n    Deletes a specific version of the schema registered under this subject.\n    This only deletes the version and the schema ID remains intact making\n    it still possible to decode data using the schema ID.\n    This API is recommended to be used only in development environments or\n    under extreme circumstances where-in, its required to delete a previously\n    registered schema for compatibility purposes or re-register previously registered schema.\n\n    Args:\n        subject (str): subject name\n        version (str): Version of the schema to be deleted.\n            Valid values for versionId are between [1,2^31-1] or the string \"latest\".\n            \"latest\" deletes the last registered schema under the specified subject.\n        headers (dict): Extra headers to add on the requests\n        timeout (httpx._client.TimeoutTypes): The timeout configuration to use when sending requests. Default USE_CLIENT_DEFAULT\n\n    Returns:\n        int: version of the schema deleted\n        None: If the subject or version does not exist.\n    \"\"\"\n</code></pre>"},{"location":"client/#test-compatibility_1","title":"Test Compatibility","text":"<pre><code>async def test_compatibility(subject: str, schema: typing.Union[client.schema.AvroSchema, client.schema.JsonSchema], version=\"latest\", headers: dict = None, timeout: typing.Union[TimeoutTypes, UseClientDefault] = USE_CLIENT_DEFAULT, schema_type: typing.Union[\"AVRO\", \"JSON\"]):\n\"\"\"\n    By default the latest version is checked against.\n\n    Args:\n        subject (str): subject name\n        schema typing.Union[client.schema.AvroSchema, client.schema.JsonSchema, str]: Avro or JSON schema to be registered\n        headers (dict): Extra headers to add on the requests\n        timeout (httpx._client.TimeoutTypes): The timeout configuration to use when sending requests. Default USE_CLIENT_DEFAULT\n        schema_type typing.Union[\"AVRO\", \"JSON\"]: The type of schema to parse if `schema` is a string. Default \"AVRO\"\n\n    Returns:\n        bool: True if schema given compatible, False otherwise\n    \"\"\"\n</code></pre>"},{"location":"client/#get-compatibility_1","title":"Get Compatibility","text":"<pre><code>async def get_compatibility(subject: str, headers: dict = None, timeout: typing.Union[TimeoutTypes, UseClientDefault] = USE_CLIENT_DEFAULT) -&gt; str:\n\"\"\"\n    Get the current compatibility level for a subject.  Result will be one of:\n\n    Args:\n        subject (str): subject name\n        headers (dict): Extra headers to add on the requests\n        timeout (httpx._client.TimeoutTypes): The timeout configuration to use when sending requests. Default USE_CLIENT_DEFAULT\n\n    Returns:\n        str: one of BACKWARD, BACKWARD_TRANSITIVE, FORWARD, FORWARD_TRANSITIVE,\n            FULL, FULL_TRANSITIVE, NONE\n\n    Raises:\n        ClientError: if the request was unsuccessful or an invalid\n        compatibility level was returned\n    \"\"\"\n</code></pre>"},{"location":"client/#update-compatibility_1","title":"Update Compatibility","text":"<pre><code>async def update_compatibility(level: str, subject: str, headers: dict = None, timeout: typing.Union[TimeoutTypes, UseClientDefault] = USE_CLIENT_DEFAULT) -&gt; bool:\n\"\"\"\n    Update the compatibility level for a subject.\n    If subject is None, the compatibility level is global.\n\n    Args:\n        level (str): one of BACKWARD, BACKWARD_TRANSITIVE, FORWARD, FORWARD_TRANSITIVE,\n            FULL, FULL_TRANSITIVE, NONE\n        headers (dict): Extra headers to add on the requests\n        timeout (httpx._client.TimeoutTypes): The timeout configuration to use when sending requests. Default USE_CLIENT_DEFAULT\n\n    Returns:\n        bool: True if compatibility was updated\n\n    Raises:\n        ClientError: if the request was unsuccessful or an invalid\n    \"\"\"\n</code></pre>"},{"location":"exceptions/","title":"ClientError","text":"<p>An instance of ClientError is returned when an error occurs.</p> <pre><code>class ClientError(Exception):\n\"\"\" Error thrown by Schema Registry clients \"\"\"\n\n    def __init__(self, message, http_code=None, server_traceback=None):\n        self.message = message\n        self.server_traceback = server_traceback\n        self.http_code = http_code\n        super(ClientError, self).__init__(self.__str__())\n\n    def __repr__(self):\n        return f\"ClientError(error={self.message})\"\n\n    def __str__(self):\n        return self.message\n</code></pre> <p>For example:</p> <pre><code>try:\n    # Try to get the compatibility level of a subject that does not exist\n    # The Schema Registry Server returns 404\n    compatibility = client.get_compatibility(\"subject-does-not-exists\")\nexcept Exception as error:\n    # Print 404\n    print(error.http_code)\n</code></pre>"},{"location":"faust/","title":"How to use it with Faust","text":"<p>This section describe how integrate this library with Faust</p>"},{"location":"faust/#schemas-custom-codecs-and-serializers","title":"Schemas, Custom Codecs and Serializers","text":"<p>Because we want to be sure that the message that we encode are valid, we can use Avro or JSON schemas. Also, Introduction to Schemas in Apache Kafka with the Confluent Schema Registry is a good post to start with <code>schemas</code>. Avro and JSON can be used to define the data schema for a record's value. This schema describes the fields allowed in the value, along with their data types.</p> <p>In order to use <code>avro schemas</code> or <code>json schemas</code> with <code>Faust</code>, we need to define a custom codec and a custom serializer able to talk with the <code>schema-registry</code>, and to do that, we will use the <code>MessageSerializer</code>.</p> <p>For serializing <code>avro schemas</code> we should use the <code>FaustSerializer</code>. For serializing <code>json schemas</code> we should use the <code>FaustJsonSerializer</code>.</p> <p>For our demonstration, let's imagine that we have the following <code>avro schema</code>:</p> <pre><code>{\n\"type\": \"record\",\n\"namespace\": \"com.example\",\n\"name\": \"AvroUsers\",\n\"fields\": [\n{\"name\": \"first_name\", \"type\": \"string\"},\n{\"name\": \"last_name\", \"type\": \"string\"}\n]\n}\n</code></pre> <p>Let's register the custom <code>codec</code></p> Trivial Usage<pre><code># codecs.codec.py\nfrom schema_registry.client import SchemaRegistryClient, schema\nfrom schema_registry.serializers.faust import FaustSerializer\n\n# create an instance of the `SchemaRegistryClient`\nclient = SchemaRegistryClient(url=settings.SCHEMA_REGISTRY_URL)\n\n# schema that we want to use. For this example we\n# are using a dict, but this schema could be located in a file called avro_user_schema.avsc\navro_user_schema = schema.AvroSchema({\n    \"type\": \"record\",\n    \"namespace\": \"com.example\",\n    \"name\": \"AvroUsers\",\n    \"fields\": [\n        {\"name\": \"first_name\", \"type\": \"string\"},\n        {\"name\": \"last_name\", \"type\": \"string\"}\n    ]\n})\n\navro_user_serializer = FaustSerializer(client, \"users\", avro_user_schema)\n\n# function used to register the codec\ndef avro_user_codec():\n    return avro_user_serializer\n</code></pre> <p>and add in <code>setup.py</code> the following code in order to tell faust where to find the custom codecs.</p> setup.py<pre><code>setup(\n    ...\n    entry_points={\n        'console_scripts': [\n            'example = example.app:main',\n        ],\n        'faust.codecs': [\n            'avro_users = example.codecs.avro:avro_user_codec',\n        ],\n    },\n)\n</code></pre> <p>or if you are using <code>poetry</code> an a <code>pyproject.toml</code> you can add in <code>pyproject.toml</code> the following code to tell faust where to find the custom codecs:</p> pyproject.toml<pre><code>[tool.poetry.scripts]\nexample = \"example.app:main\"\n\n[tool.poetry.plugins.\"faust.codecs\"]\navro_users = \"example.codecs.avro:avro_user_codec\"\n</code></pre> <p>Now the final step is to integrate the faust model with the AvroSerializer.</p> user.models.py<pre><code>import faust\n\n\nclass UserModel(faust.Record, serializer='avro_users'):\n    first_name: str\n    last_name: str\n</code></pre> <p>Now our application is able to send and receive message using arvo schemas!!!! :-)</p> application<pre><code>import logging\n\nfrom your_project.app import app\nfrom .codecs.codec import avro_user_serializer\nfrom .models import UserModel\n\nusers_topic = app.topic('avro_users', partitions=1, value_type=UserModel)\n\nlogger = logging.getLogger(__name__)\n\n\n@app.agent(users_topic)\nasync def users(users):\n    async for user in users:\n        logger.info(\"Event received in topic avro_users\")\n        logger.info(f\"First Name: {user.first_name}, last name {user.last_name}\")\n\n\n@app.timer(5.0, on_leader=True)\nasync def publish_users():\n    logger.info('PUBLISHING ON LEADER FOR USERS APP!')\n    user = {\"first_name\": \"foo\", \"last_name\": \"bar\"}\n    await users.send(value=user, value_serializer=avro_user_serializer)\n</code></pre> <p>The full example is here</p>"},{"location":"faust/#usage-with-dataclasses-avroschema-for-avro-schemas","title":"Usage with dataclasses-avroschema for avro schemas","text":"<p>You can also use this funcionality with dataclasses-avroschema and you won't have to provide the avro schema. The only thing that you need to do is add the <code>AvroModel</code> class and use its methods:</p> user.models.py<pre><code>import faust\n\nfrom dataclasses_avroschema import AvroModel\n\n\nclass UserModel(faust.Record, AvroModel, serializer='avro_users'):\n    first_name: str\n    last_name: str\n\n\n# codecs.codec.py\nfrom schema_registry.client import SchemaRegistryClient, schema\nfrom schema_registry.serializers.faust import FaustSerializer\n\nfrom users.models import UserModel\n\n# create an instance of the `SchemaRegistryClient`\nclient = SchemaRegistryClient(url=settings.SCHEMA_REGISTRY_URL)\n\navro_user_serializer = FaustSerializer(client, \"users\", UserModel.avro_schema())  # usign the method avro_schema to get the avro schema representation\n\n# function used to register the codec\ndef avro_user_codec():\n    return avro_user_serializer\n</code></pre>"},{"location":"faust/#usage-with-pydantic-for-json-schemas","title":"Usage with pydantic for json schemas","text":"<p>You can also use this funcionality with dataclasses-pydantic and you won't have to provide the json schema. The only thing that you need to do is add the <code>BaseModel</code> class and use its methods:</p> users.models.py<pre><code>import faust\n\nfrom pydantic import BaseModel\n\n\nclass UserModel(faust.Record, BaseModel, serializer='json_users'):\n    first_name: str\n    last_name: str\n\n\n# codecs.codec.py\nfrom schema_registry.client import SchemaRegistryClient, schema\nfrom schema_registry.serializers.faust import FaustJsonSerializer\n\nfrom users.models import UserModel\n\n# create an instance of the `SchemaRegistryClient`\nclient = SchemaRegistryClient(url=settings.SCHEMA_REGISTRY_URL)\n\njson_user_serializer = FaustJsonSerializer(client, \"users\", UserModel.schema_json())  # usign the method schema_json to get the json schema representation\n\n# function used to register the codec\ndef json_user_codec():\n    return json_user_serializer\n</code></pre>"},{"location":"schemaregistry_server/","title":"Schema Registry Server","text":"<p>This section provides you just an introduction about the <code>Schema Server</code>.</p> <p>Schema Registry provides a serving layer for your metadata. It provides a RESTful interface for storing and retrieving Avro or JSON schemas. It stores a versioned history of all schemas, provides multiple compatibility settings and allows evolution of schemas according to the configured compatibility settings and expanded Avro or JSON support. It provides serializers that plug into Apache Kafka\u00ae clients that handle schema storage and retrieval for Kafka messages that are sent in the Avro or JSON format.</p> <p>Schema Registry is a distributed storage layer for Avro or JSON Schemas which uses Kafka as its underlying storage mechanism. Some key design decisions:</p> <ol> <li>Assigns globally unique ID to each registered schema. Allocated IDs are guaranteed to be monotonically increasing but not necessarily consecutive.</li> <li>Kafka provides the durable backend, and functions as a write-ahead changelog for the state of Schema Registry and the schemas it contains.</li> <li>Schema Registry is designed to be distributed, with single-primary architecture, and ZooKeeper/Kafka coordinates primary election (based on the configuration).</li> </ol>"},{"location":"schemaregistry_server/#api","title":"API","text":""},{"location":"schemaregistry_server/#schemas","title":"Schemas","text":"<p><code>GET /schemas/ids/{int: id}</code> - Get the schema string identified by the input ID</p>"},{"location":"schemaregistry_server/#subjects","title":"Subjects","text":"<p><code>GET /subjects</code> - Get a list of registered subjects.</p> <p><code>GET /subjects/(string: subject)/versions</code> - Get a list of versions registered under the specified subject</p> <p><code>GET /schemas/ids/{int: id}/versions</code> - Get the subject-version pairs identified by the input ID.</p> <p><code>DELETE /subjects/(string: subject)</code> - Deletes the specified subject and its associated compatibility level if registered. It is recommended to use this API only when a topic needs to be recycled or in development environment.</p> <p><code>GET /subjects/(string: subject)/versions/(versionId: version)</code> - Get a specific version of the schema registered under this subject Check response</p> <p><code>GET /subjects/(string: subject)/versions/(versionId: version)/schema</code> - Get the avro or json schema for the specified version of this subject. The unescaped schema only is returned. [Missing]</p> <p><code>POST /subjects/(string: subject)/versions</code> - Register a new schema under the specified subject and receive a schema id</p> <p><code>POST /subjects/(string: subject)</code> - Check if a schema has already been registered under the specified subject. If so, this returns the schema string along with its globally unique identifier, its version under this subject and the subject name.</p> <p><code>DELETE /subjects/(string: subject)/versions/(versionId: version)</code> - Deletes a specific version of the schema registered under this subject. This only deletes the version and the schema ID remains intact making it still possible to decode data using the schema ID. This API is recommended to be used only in development environments or under extreme circumstances where-in, its required to delete a previously registered schema for compatibility purposes or re-register previously registered schema. [Missing]</p>"},{"location":"schemaregistry_server/#compatibility","title":"Compatibility","text":"<p><code>POST /compatibility/subjects/(string: subject)/versions/(versionId: version)</code> - Test input schema against a particular version of a subject's schema for compatibility. Note that the compatibility level applied for the check is the configured compatibility level for the subject (http:get:: /config/(string: subject)). If this subject's compatibility level was never changed, then the global compatibility level applies (http:get:: /config).</p> <p>These are the compatibility types:</p> <p>BACKWARD: (default) consumers using the new schema can read data written by producers using the latest registered schema</p> <p>BACKWARD_TRANSITIVE: consumers using the new schema can read data written by producers using all previously registered schemas</p> <p>FORWARD: consumers using the latest registered schema can read data written by producers using the new schema</p> <p>FORWARD_TRANSITIVE: consumers using all previously registered schemas can read data written by producers using the new schema</p> <p>FULL: the new schema is forward and backward compatible with the latest registered schema</p> <p>FULL_TRANSITIVE: the new schema is forward and backward compatible with all previously registered schemas</p> <p>NONE: schema compatibility checks are disabled</p>"},{"location":"schemaregistry_server/#config","title":"Config","text":"<p><code>GET /config</code> - Get global compatibility level.</p> <p><code>PUT /config</code> - Update global compatibility level. [Missing]</p> <p><code>GET /config/(string: subject)</code> - Get compatibility level for a subject. [Missing]</p> <p><code>PUT /config/(string: subject)</code> - Update compatibility level for the specified subject.</p> <p>Too know more about the API go here</p>"},{"location":"schemas/","title":"Schemas","text":""},{"location":"schemas/#baseschema","title":"BaseSchema","text":"<p><code>BaseSchema</code> an abstract base class from which <code>AvroSchema</code> and <code>JsonSchema</code> inherit. Requires concrete classes implement the following methods.</p> <pre><code>@abstractmethod\ndef parse_schema(self, schema: typing.Dict) -&gt; typing.Dict:\n    pass\n\n@staticmethod\n@abstractmethod\ndef load(fp: str) -&gt; BaseSchema:\n\"\"\"Parse a schema from a file path\"\"\"\n    pass\n\n@staticmethod\n@abstractmethod\nasync def async_load(fp: str) -&gt; BaseSchema:\n\"\"\"Parse a schema from a file path\"\"\"\n    pass\n\n@property\n@abstractmethod\ndef name(self) -&gt; typing.Optional[str]:\n    pass\n\n@property\n@abstractmethod\ndef schema_type(self) -&gt; str:\n    pass\n</code></pre>"},{"location":"schemas/#avroschema","title":"AvroSchema","text":"<p><code>AvroSchema</code> parses strings into avro schemas to assure validation. Properties:</p> <p><code>raw_schema</code>: The input string that will be parsed</p> <p><code>schema</code>: Result of parsing the raw_schema with <code>fastavro</code></p> <p><code>flat_schema</code>: Parsed schema without <code>__fastavro_parsed</code> flag</p> <p><code>expanded_schema</code>: Parsed schema where all named types are expanded to their real schema</p>"},{"location":"schemas/#jsonschema","title":"JsonSchema","text":"<p><code>JsonSchema</code> parses strings into json schemas to assure validation. Properties:</p> <p><code>raw_schema</code>: The input string that will be parsed</p> <p><code>schema</code>: Result of parsing the raw_schema with <code>jsonschema.Draft7Validator.check_schema</code></p>"},{"location":"schemas/#schemaversion","title":"SchemaVersion","text":"<p><code>SchemaVersion</code> is a <code>namedtuple</code> that contains the <code>subject</code>, <code>schema_id</code>, <code>version</code> and either <code>AvroSchema</code> or <code>JsonSchema</code>.</p> <p>The <code>SchemaVersion</code> is returned by <code>get_schema</code> and <code>check_version</code> client methods</p>"},{"location":"serializer/","title":"Message Serializers","text":"<p>To serialize and deserialize messages you can use <code>AvroMessageSerializer</code> and <code>JsonMessageSerializer</code>. They interact with the <code>SchemaRegistryClient</code> to get <code>avro Schemas</code>  and <code>json schemas</code> in order to process messages.</p> <p>If you want to run the following examples run <code>docker-compose up</code> and the <code>schema registry server</code> will run on <code>http://127.0.0.1:8081</code></p> <p>Warning</p> <p>The <code>AvroMessageSerializer</code> uses the same <code>protocol</code> as confluent, meaning that the event will contain the schema id in the payload. If you produce an event with the <code>AvroMessageSerializer</code> you have to consume it with the <code>AvroMessageSerializer</code> as well, otherwise you have to implement the parser on the consumer side.</p> class <code>schema_registry.serializers.AvroMessageSerializer</code>(schemaregistry_client, reader_schema=None, return_record_name=False) <p>AvroMessageSerializer to serialize and deserialize messages</p> <p>Parameters:</p> <ul> <li>schemaregistry_client - schema_registry.client.AsyncSchemaRegistryClient: Http Client</li> <li>reader_schema - schema_registry.schema.AvroSchema: Specify a schema to decode the message</li> <li>return_record_name - bool: If the record name should be returned</li> </ul>"},{"location":"serializer/#usage-for-avro-schemas","title":"Usage for avro schemas","text":"Trivial Usage with avro<pre><code>from schema_registry.client import SchemaRegistryClient, schema\nfrom schema_registry.serializers import AvroMessageSerializer\n\n\nclient = SchemaRegistryClient(\"http://127.0.0.1:8081\")\navro_message_serializer = AvroMessageSerializer(client)\n\navro_user_schema = schema.AvroSchema({\n    \"type\": \"record\",\n    \"namespace\": \"com.example\",\n    \"name\": \"AvroUsers\",\n    \"fields\": [\n        {\"name\": \"first_name\", \"type\": \"string\"},\n        {\"name\": \"last_name\", \"type\": \"string\"},\n        {\"name\": \"age\", \"type\": \"int\"},\n\n    ],\n})\n\n# We want to encode the user_record with avro_user_schema\nuser_record = {\n    \"first_name\": \"my_first_name\",\n    \"last_name\": \"my_last_name\",\n    \"age\": 20,\n}\n\n# Encode the record\nmessage_encoded = avro_message_serializer.encode_record_with_schema(\n    \"user\", avro_user_schema, user_record)\n\n# this is because the message encoded reserved 5 bytes for the schema_id\nassert len(message_encoded) &gt; 5\nassert isinstance(message_encoded, bytes)\n\n# Decode the message\nmessage_decoded = avro_message_serializer.decode_message(message_encoded)\nassert message_decoded == user_record\n\n# Now if we send a bad record\nbad_record = {\n    \"first_name\": \"my_first_name\",\n    \"last_name\": \"my_last_name\",\n    \"age\": \"my_age\"\n}\n\navro_message_serializer.encode_record_with_schema(\n    \"user\", avro_user_schema, bad_record)\n\n# &gt;&gt;&gt; TypeError: an integer is required on field age\n</code></pre> <p>(This script is complete, it should run \"as is\")</p>"},{"location":"serializer/#usage-for-json-schemas","title":"Usage for json schemas","text":"class <code>schema_registry.serializers.JsonMessageSerializer</code>(schemaregistry_client, reader_schema=None, return_record_name=False) <p>JsonMessageSerializer to serialize and deserialize messages</p> <p>Parameters:</p> <ul> <li>schemaregistry_client - schema_registry.client.AsyncSchemaRegistryClient: Http Client</li> <li>reader_schema - schema_registry.schema.AvroSchema: Specify a schema to decode the message</li> <li>return_record_name - bool: If the record name should be returned</li> </ul> Trivial Usage with json schemas<pre><code>from schema_registry.client import SchemaRegistryClient, schema\nfrom schema_registry.serializers import JsonMessageSerializer\n\n\nclient = SchemaRegistryClient(\"http://127.0.0.1:8081\")\njson_message_serializer = JsonMessageSerializer(client)\n\njson_schema = schema.JsonSchema({\n  \"definitions\" : {\n    \"record:python.test.basic.basic\" : {\n      \"description\" : \"basic schema for tests\",\n      \"type\" : \"object\",\n      \"required\" : [ \"number\", \"name\" ],\n      \"properties\" : {\n        \"number\" : {\n          \"oneOf\" : [ {\n            \"type\" : \"integer\"\n          }, {\n            \"type\" : \"null\"\n          } ]\n        },\n        \"name\" : {\n          \"oneOf\" : [ {\n            \"type\" : \"string\"\n          } ]\n        }\n      }\n    }\n  },\n  \"$ref\" : \"#/definitions/record:python.test.basic.basic\"\n})\n\n# Encode the record\nbasic_record = {\n    \"number\": 10,\n    \"name\": \"a_name\",\n}\n\nmessage_encoded = json_message_serializer.encode_record_with_schema(\n    \"basic\", json_schema, basic_record)\n\n# this is because the message encoded reserved 5 bytes for the schema_id\nassert len(message_encoded) &gt; 5\nassert isinstance(message_encoded, bytes)\n\n# Decode the message\nmessage_decoded = json_message_serializer.decode_message(message_encoded)\nassert message_decoded == basic_record\n</code></pre> <p>(This script is complete, it should run \"as is\")</p>"},{"location":"serializer/#async-implementations","title":"Async implementations","text":"<p>Please note that <code>JsonMessageSerializer</code>, <code>AvroMessageSerializer</code> and <code>SchemaRegistryClient</code> have their asynchronous counterparts <code>AsyncJsonMessageSerializer</code>, <code>AsyncAvroMessageSerializer</code> and <code>AsyncSchemaRegistryClient</code> and all  examples above should work if you replace them with their async variations</p> class <code>schema_registry.serializers.AsyncAvroMessageSerializer</code>(schemaregistry_client, reader_schema=None, return_record_name=False) <p>AsyncAvroMessageSerializer to serialize and deserialize messages asynchronously</p> <p>Parameters:</p> <ul> <li>schemaregistry_client - schema_registry.client.AsyncSchemaRegistryClient: Http Client</li> <li>reader_schema - schema_registry.schema.AvroSchema: Specify a schema to decode the message</li> <li>return_record_name - bool: If the record name should be returned</li> </ul> class <code>schema_registry.serializers.AsyncJsonMessageSerializer</code>(schemaregistry_client, reader_schema=None, return_record_name=False) <p>AsyncJsonMessageSerializer to serialize and deserialize messages asynchronously</p> <p>Parameters:</p> <ul> <li>schemaregistry_client - schema_registry.client.AsyncSchemaRegistryClient: Http Client</li> <li>reader_schema - schema_registry.schema.AvroSchema: Specify a schema to decode the message</li> <li>return_record_name - bool: If the record name should be returned</li> </ul>"},{"location":"serializer/#classes-and-methods","title":"Classes and Methods","text":"<pre><code>AvroMessageSerializer\n    Args:\n        schemaregistry_client (schema_registry.client.SchemaRegistryClient): Http Client\n\nJsonMessageSerializer\n    Args:\n        schemaregistry_client (schema_registry.client.SchemaRegistryClient): Http Client\n\nAsyncAvroMessageSerializer\n    Args:\n        schemaregistry_client (schema_registry.client.AsyncSchemaRegistryClient): Http Client\n\nAsyncJsonMessageSerializer\n    Args:\n        schemaregistry_client (schema_registry.client.AsyncSchemaRegistryClient): Http Client\n</code></pre>"},{"location":"serializer/#encode-record-with-a-schema","title":"Encode record with a <code>Schema</code>","text":"<pre><code>def encode_record_with_schema(subject, schema, record):\n\"\"\"\n    Args:\n        subject (str): Subject name\n        schema (avro.schema.RecordSchema): Avro Schema\n        record (dict): An object to serialize\n\n    Returns:\n        bytes: Encoded record with schema ID as bytes\n    \"\"\"\n</code></pre>"},{"location":"serializer/#encode-a-record-with-a-schema-id","title":"Encode a record with a <code>schema id</code>","text":"<pre><code>def encode_record_with_schema_id(schema_id, record):\n\"\"\"\n    Args:\n        schema_id (int): integer ID\n        record (dict): An object to serialize\n\n    Returns:\n        func: decoder function\n    \"\"\"\n</code></pre>"},{"location":"serializer/#decode-a-message-encoded-previously","title":"Decode a message encoded previously","text":"<pre><code>def decode_message(message):\n\"\"\"\n    Args:\n        message (str|bytes or None): message key or value to be decoded\n\n    Returns:\n        dict: Decoded message contents.\n    \"\"\"\n</code></pre>"}]}